<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PyEvolAlg.operatorFunctions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PyEvolAlg.operatorFunctions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import random
import numpy as np
import scipy as sp
import scipy.stats


## Mutation and recombination methods
def xorMask(vector, n, mode=&#34;byte&#34;):
    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)

    if mode == &#34;bin&#34;:
        mask = mask_pos
    elif mode == &#34;byte&#34;:
        mask = np.random.randint(1, 0xFF, size=vector.shape) * mask_pos
    elif mode == &#34;int&#34;:
        mask = np.random.randint(1, 0xFFFF, size=vector.shape) * mask_pos

    return vector ^ mask


def xorCross(vector1, vector2):
    return vector1 ^ vector2


def permutation(vector, n):
    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)

    if np.count_nonzero(mask_pos==1) &lt; 2:
        mask[random.sample(range(mask_pos.size), 2)] = 1 
    np.random.shuffle(vector[mask_pos])
    return vector


def mutateRand(vector, population, params):
    method = params[&#34;method&#34;]
    n = round(params[&#34;N&#34;])

    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1
    
    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)
    
    rand_vec = sampleDistribution(method, n, 0, strength, low, up)
    
    vector[mask_pos] = vector[mask_pos] + rand_vec
    return vector


def mutateSample(vector, population, params):
    method = params[&#34;method&#34;]
    n = round(params[&#34;N&#34;])

    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1

    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)
    popul_matrix = np.vstack([i.vector for i in population])
    mean = popul_matrix.mean(axis=0)[mask_pos]
    std = (popul_matrix.std(axis=0)[mask_pos] + 1e-6)*strength # ensure there will be some standard deviation
    
    rand_vec = sampleDistribution(method, n, mean, std, low, up)
    
    vector[mask_pos] = rand_vec
    return vector


def randSample(vector, population, params):
    method = params[&#34;method&#34;]
    
    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1

    popul_matrix = np.vstack([i.vector for i in population])
    mean = popul_matrix.mean(axis=0)
    std = (popul_matrix.std(axis=0) + 1e-6)*strength # ensure there will be some standard deviation
    
    rand_vec = sampleDistribution(method, vector.shape, mean, std, low, up)
    
    return rand_vec


def randNoise(vector, params):
    method = params[&#34;method&#34;]

    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1
    
    noise = sampleDistribution(method, vector.shape, 0, strength, low, up)
    
    return vector + noise


def sampleDistribution(method, n, mean=0, strength=0.01, low=0, up=1):
    sample = 0 
    if method == &#34;Gauss&#34;:
        sample = np.random.normal(mean, strength, size=n)
    elif method == &#34;Uniform&#34;:
        sample = np.random.uniform(low, up, size=n)
    elif method == &#34;Cauchy&#34;:
        sample = sp.stats.cauchy.rvs(mean, strength, size=n)
    elif method == &#34;Laplace&#34;:
        sample = sp.stats.laplace.rvs(mean, strength, size=n)
    elif method == &#34;Poisson&#34;:
        sample = sp.stats.poisson.rvs(strength, size=n)
    else:
        print(f&#34;Error: distribution \&#34;{method}\&#34; not defined&#34;)
        exit(1)
    return sample


def laplace(vector, strength):
    return randNoise(vector, {&#34;method&#34;:&#34;Laplace&#34;, &#34;F&#34;:strength})


def cauchy(vector, strength):
    return randNoise(vector, {&#34;method&#34;:&#34;Cauchy&#34;, &#34;F&#34;:strength})


def gaussian(vector, strength):
    return randNoise(vector, {&#34;method&#34;:&#34;Gauss&#34;, &#34;F&#34;:strength})


def uniform(vector, low, up):
    return randNoise(vector, {&#34;method&#34;:&#34;Uniform&#34;, &#34;Low&#34;:low, &#34;Up&#34;:up})


def poisson(vector, mu):
    return randNoise(vector, {&#34;method&#34;:&#34;Poisson&#34;, &#34;F&#34;:mu})

&#34;&#34;&#34;
-Distribución zeta
-Distribución hipergeométrica
-Distribución geomética
-Distribución de Boltzman
-Distribución de Pascal (binomial negativa)
&#34;&#34;&#34;

def cross1p(vector1, vector2):
    cross_point = random.randrange(0, vector1.size)
    return np.hstack([vector1[:cross_point], vector2[cross_point:]])


def cross2p(vector1, vector2):
    cross_point1 = random.randrange(0, vector1.size-2)
    cross_point2 = random.randrange(cross_point1, vector1.size)
    return np.hstack([vector1[:cross_point1], vector2[cross_point1:cross_point2], vector1[cross_point2:]])


def crossMp(vector1, vector2):
    mask_pos = 1*(np.random.rand(vector1.size) &gt; 0.5)
    aux = np.copy(vector1)
    aux[mask_pos==1] = vector2[mask_pos==1]
    return aux


def multiCross(vector, population, n_ind):
    result = vector
    if n_ind &lt;= len(population):
        n_ind = len(population)-1
        mask_pos = np.random.randint(n_ind, size=vector.size)
        parents = random.sample(population, n_ind)
        aux = np.copy(vector)
        for i in range(1, n_ind-1):
            aux[mask_pos==i] = parents[i].vector[mask_pos==i]
        result = aux
    return result


def blxalpha(vector1, vector2, alpha):
    alpha *= np.random.random()
    return alpha*vector1 + (1-alpha)*vector2


def sbx(vector1, vector2, strength):
    beta = np.zeros(vector1.shape)
    u = np.random.random(vector1.shape)
    for idx, val in enumerate(u):
        if val &lt;= 0.5:
            beta[idx] = (2*val)**(1/(strength+1))
        else:
            beta[idx] = (0.5*(1-val))**(1/(strength+1))
    
    sign = random.choice([-1,1])
    return 0.5*(vector1+vector2) + sign*0.5*beta*(vector1-vector2)


def simAnnealing(solution, strength, objfunc, temp_changes, iter):
    p0, pf = (0.1, 7)

    alpha = 0.99
    best_fit = solution.fitness

    temp_init = temp = 100
    temp_fin = alpha**temp_changes * temp_init
    vector_new = solution.vector
    while temp &gt;= temp_fin:
        for j in range(iter):
            vector_new = gaussian(vector_new, strength)
            new_fit = objfunc.fitness(vector_new)
            y = ((pf-p0)/(temp_fin-temp_init))*(temp-temp_init) + p0 

            p = np.exp(-y)
            if new_fit &gt; best_fit or random.random() &lt; p:
                best_fit = new_fit
        temp = temp*alpha
    return vector_new


def harmonySearch(vector, population, strength, HMCR, PAR):
    new_vector = np.zeros(vector.shape)
    popul_matrix = np.vstack([i.vector for i in population])
    popul_mean = popul_matrix.mean(axis=0)
    popul_std = popul_matrix.std(axis=0)
    for i in range(vector.size):
        if random.random() &lt; HMCR:
            new_vector[i] = random.choice(population).vector[i]
            if random.random() &lt;= PAR:
                new_vector[i] += np.random.normal(0,strength)
        else:
            new_vector[i] = np.random.normal(popul_mean[i], popul_std[i])
    return new_vector


def DERand1(vector, population, F, CR):
    if len(population) &gt; 3:
        r1, r2, r3 = random.sample(population, 3)

        v = r1.vector + F*(r2.vector-r3.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def DEBest1(vector, population, F, CR):
    if len(population) &gt; 3:
        fitness = [i.fitness for i in population]
        best = population[fitness.index(max(fitness))]
        r1, r2 = random.sample(population, 2)

        v = best.vector + F*(r1.vector-r2.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def DERand2(vector, population, F, CR):
    if len(population) &gt; 5:
        r1, r2, r3, r4, r5 = random.sample(population, 5)

        v = r1.vector + F*(r2.vector-r3.vector) + F*(r4.vector-r5.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def DEBest2(vector, population, F, CR):
    if len(population) &gt; 5:
        fitness = [i.fitness for i in population]
        best = population[fitness.index(max(fitness))]
        r1, r2, r3, r4 = random.sample(population, 4)

        v = best.vector + F*(r1.vector-r2.vector) + F*(r3.vector-r4.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def DECurrentToBest1(vector, population, F, CR):
    if len(population) &gt; 3:
        fitness = [i.fitness for i in population]
        best = population[fitness.index(max(fitness))]
        r1, r2 = random.sample(population, 2)

        v = vector + F*(best.vector-vector) + F*(r1.vector-r2.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def DECurrentToRand1(vector, population, F, CR):
    if len(population) &gt; 3:
        r1, r2, r3 = random.sample(population, 3)

        v = vector + np.random.random()*(r1.vector-vector) + F*(r2.vector-r3.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def DECurrentToPBest1(vector, population, F, CR, P):
    if len(population) &gt; 3:
        fitness = [i.fitness for i in population]
        upper_idx = max(1, math.ceil(len(population)*P))
        pbest_idx = random.choice(np.argsort(fitness)[:upper_idx])
        pbest = population[pbest_idx]
        r1, r2 = random.sample(population, 2)

        v = vector + F*(pbest.vector-vector) + F*(r1.vector-r2.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector


def pso_operator(solution, population, objfunc, w, c1, c2):
    fitness_list = [i.fitness for i in self.population]
    best_idx = fitness_list.index(max(fitness_list))
    best_particle = self.population[best_idx]

    c1 = c1 * np.random.random(val.vector.shape) 
    c2 = c2 * np.random.random(val.vector.shape) 

    solution.speed = w * solution.speed + c1 * (solution.best - solution.vector) + c2 * (best_particle - solution.vector)
    new_solution = solution.apply_speed()
    return new_solution.vector


def firefly(solution, population, objfunc, alpha_0, beta_0, delta, gamma):
    sol_range = objfunc.sup_lim - objfunc.inf_lim
    n_dim = solution.vector.size
    new_vector = solution.vector.copy()
    for idx, ind in enumerate(population):
        if solution.fitness &lt; ind.fitness:
            r = np.linalg.norm(solution.vector - ind.vector)
            alpha = alpha_0 * delta ** idx
            beta = beta_0 * np.exp(-gamma*(r/(sol_range*np.sqrt(n_dim)))**2)
            new_vector = new_solution + beta*(ind.vector-new_vector) + alpha * sol_range * random.random()-0.5
            new_vector = objfunc.check_bounds(new_vector)
    
    return new_solution


def dummyOp(vector, scale=1000):
    &#34;&#34;&#34;
    Only for testing, not useful for real applications
    &#34;&#34;&#34;
    return np.ones(vector.shape)*scale</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PyEvolAlg.operatorFunctions.DEBest1"><code class="name flex">
<span>def <span class="ident">DEBest1</span></span>(<span>vector, population, F, CR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DEBest1(vector, population, F, CR):
    if len(population) &gt; 3:
        fitness = [i.fitness for i in population]
        best = population[fitness.index(max(fitness))]
        r1, r2 = random.sample(population, 2)

        v = best.vector + F*(r1.vector-r2.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.DEBest2"><code class="name flex">
<span>def <span class="ident">DEBest2</span></span>(<span>vector, population, F, CR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DEBest2(vector, population, F, CR):
    if len(population) &gt; 5:
        fitness = [i.fitness for i in population]
        best = population[fitness.index(max(fitness))]
        r1, r2, r3, r4 = random.sample(population, 4)

        v = best.vector + F*(r1.vector-r2.vector) + F*(r3.vector-r4.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.DECurrentToBest1"><code class="name flex">
<span>def <span class="ident">DECurrentToBest1</span></span>(<span>vector, population, F, CR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DECurrentToBest1(vector, population, F, CR):
    if len(population) &gt; 3:
        fitness = [i.fitness for i in population]
        best = population[fitness.index(max(fitness))]
        r1, r2 = random.sample(population, 2)

        v = vector + F*(best.vector-vector) + F*(r1.vector-r2.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.DECurrentToPBest1"><code class="name flex">
<span>def <span class="ident">DECurrentToPBest1</span></span>(<span>vector, population, F, CR, P)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DECurrentToPBest1(vector, population, F, CR, P):
    if len(population) &gt; 3:
        fitness = [i.fitness for i in population]
        upper_idx = max(1, math.ceil(len(population)*P))
        pbest_idx = random.choice(np.argsort(fitness)[:upper_idx])
        pbest = population[pbest_idx]
        r1, r2 = random.sample(population, 2)

        v = vector + F*(pbest.vector-vector) + F*(r1.vector-r2.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.DECurrentToRand1"><code class="name flex">
<span>def <span class="ident">DECurrentToRand1</span></span>(<span>vector, population, F, CR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DECurrentToRand1(vector, population, F, CR):
    if len(population) &gt; 3:
        r1, r2, r3 = random.sample(population, 3)

        v = vector + np.random.random()*(r1.vector-vector) + F*(r2.vector-r3.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.DERand1"><code class="name flex">
<span>def <span class="ident">DERand1</span></span>(<span>vector, population, F, CR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DERand1(vector, population, F, CR):
    if len(population) &gt; 3:
        r1, r2, r3 = random.sample(population, 3)

        v = r1.vector + F*(r2.vector-r3.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.DERand2"><code class="name flex">
<span>def <span class="ident">DERand2</span></span>(<span>vector, population, F, CR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DERand2(vector, population, F, CR):
    if len(population) &gt; 5:
        r1, r2, r3, r4, r5 = random.sample(population, 5)

        v = r1.vector + F*(r2.vector-r3.vector) + F*(r4.vector-r5.vector)
        mask_pos = np.random.random(vector.shape) &lt;= CR
        vector[mask_pos] = v[mask_pos]
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.blxalpha"><code class="name flex">
<span>def <span class="ident">blxalpha</span></span>(<span>vector1, vector2, alpha)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blxalpha(vector1, vector2, alpha):
    alpha *= np.random.random()
    return alpha*vector1 + (1-alpha)*vector2</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.cauchy"><code class="name flex">
<span>def <span class="ident">cauchy</span></span>(<span>vector, strength)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cauchy(vector, strength):
    return randNoise(vector, {&#34;method&#34;:&#34;Cauchy&#34;, &#34;F&#34;:strength})</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.cross1p"><code class="name flex">
<span>def <span class="ident">cross1p</span></span>(<span>vector1, vector2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross1p(vector1, vector2):
    cross_point = random.randrange(0, vector1.size)
    return np.hstack([vector1[:cross_point], vector2[cross_point:]])</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.cross2p"><code class="name flex">
<span>def <span class="ident">cross2p</span></span>(<span>vector1, vector2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross2p(vector1, vector2):
    cross_point1 = random.randrange(0, vector1.size-2)
    cross_point2 = random.randrange(cross_point1, vector1.size)
    return np.hstack([vector1[:cross_point1], vector2[cross_point1:cross_point2], vector1[cross_point2:]])</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.crossMp"><code class="name flex">
<span>def <span class="ident">crossMp</span></span>(<span>vector1, vector2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossMp(vector1, vector2):
    mask_pos = 1*(np.random.rand(vector1.size) &gt; 0.5)
    aux = np.copy(vector1)
    aux[mask_pos==1] = vector2[mask_pos==1]
    return aux</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.dummyOp"><code class="name flex">
<span>def <span class="ident">dummyOp</span></span>(<span>vector, scale=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Only for testing, not useful for real applications</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dummyOp(vector, scale=1000):
    &#34;&#34;&#34;
    Only for testing, not useful for real applications
    &#34;&#34;&#34;
    return np.ones(vector.shape)*scale</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.firefly"><code class="name flex">
<span>def <span class="ident">firefly</span></span>(<span>solution, population, objfunc, alpha_0, beta_0, delta, gamma)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def firefly(solution, population, objfunc, alpha_0, beta_0, delta, gamma):
    sol_range = objfunc.sup_lim - objfunc.inf_lim
    n_dim = solution.vector.size
    new_vector = solution.vector.copy()
    for idx, ind in enumerate(population):
        if solution.fitness &lt; ind.fitness:
            r = np.linalg.norm(solution.vector - ind.vector)
            alpha = alpha_0 * delta ** idx
            beta = beta_0 * np.exp(-gamma*(r/(sol_range*np.sqrt(n_dim)))**2)
            new_vector = new_solution + beta*(ind.vector-new_vector) + alpha * sol_range * random.random()-0.5
            new_vector = objfunc.check_bounds(new_vector)
    
    return new_solution</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.gaussian"><code class="name flex">
<span>def <span class="ident">gaussian</span></span>(<span>vector, strength)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian(vector, strength):
    return randNoise(vector, {&#34;method&#34;:&#34;Gauss&#34;, &#34;F&#34;:strength})</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.harmonySearch"><code class="name flex">
<span>def <span class="ident">harmonySearch</span></span>(<span>vector, population, strength, HMCR, PAR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def harmonySearch(vector, population, strength, HMCR, PAR):
    new_vector = np.zeros(vector.shape)
    popul_matrix = np.vstack([i.vector for i in population])
    popul_mean = popul_matrix.mean(axis=0)
    popul_std = popul_matrix.std(axis=0)
    for i in range(vector.size):
        if random.random() &lt; HMCR:
            new_vector[i] = random.choice(population).vector[i]
            if random.random() &lt;= PAR:
                new_vector[i] += np.random.normal(0,strength)
        else:
            new_vector[i] = np.random.normal(popul_mean[i], popul_std[i])
    return new_vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>vector, strength)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def laplace(vector, strength):
    return randNoise(vector, {&#34;method&#34;:&#34;Laplace&#34;, &#34;F&#34;:strength})</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.multiCross"><code class="name flex">
<span>def <span class="ident">multiCross</span></span>(<span>vector, population, n_ind)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiCross(vector, population, n_ind):
    result = vector
    if n_ind &lt;= len(population):
        n_ind = len(population)-1
        mask_pos = np.random.randint(n_ind, size=vector.size)
        parents = random.sample(population, n_ind)
        aux = np.copy(vector)
        for i in range(1, n_ind-1):
            aux[mask_pos==i] = parents[i].vector[mask_pos==i]
        result = aux
    return result</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.mutateRand"><code class="name flex">
<span>def <span class="ident">mutateRand</span></span>(<span>vector, population, params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutateRand(vector, population, params):
    method = params[&#34;method&#34;]
    n = round(params[&#34;N&#34;])

    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1
    
    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)
    
    rand_vec = sampleDistribution(method, n, 0, strength, low, up)
    
    vector[mask_pos] = vector[mask_pos] + rand_vec
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.mutateSample"><code class="name flex">
<span>def <span class="ident">mutateSample</span></span>(<span>vector, population, params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutateSample(vector, population, params):
    method = params[&#34;method&#34;]
    n = round(params[&#34;N&#34;])

    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1

    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)
    popul_matrix = np.vstack([i.vector for i in population])
    mean = popul_matrix.mean(axis=0)[mask_pos]
    std = (popul_matrix.std(axis=0)[mask_pos] + 1e-6)*strength # ensure there will be some standard deviation
    
    rand_vec = sampleDistribution(method, n, mean, std, low, up)
    
    vector[mask_pos] = rand_vec
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.permutation"><code class="name flex">
<span>def <span class="ident">permutation</span></span>(<span>vector, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permutation(vector, n):
    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)

    if np.count_nonzero(mask_pos==1) &lt; 2:
        mask[random.sample(range(mask_pos.size), 2)] = 1 
    np.random.shuffle(vector[mask_pos])
    return vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.poisson"><code class="name flex">
<span>def <span class="ident">poisson</span></span>(<span>vector, mu)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poisson(vector, mu):
    return randNoise(vector, {&#34;method&#34;:&#34;Poisson&#34;, &#34;F&#34;:mu})</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.pso_operator"><code class="name flex">
<span>def <span class="ident">pso_operator</span></span>(<span>solution, population, objfunc, w, c1, c2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pso_operator(solution, population, objfunc, w, c1, c2):
    fitness_list = [i.fitness for i in self.population]
    best_idx = fitness_list.index(max(fitness_list))
    best_particle = self.population[best_idx]

    c1 = c1 * np.random.random(val.vector.shape) 
    c2 = c2 * np.random.random(val.vector.shape) 

    solution.speed = w * solution.speed + c1 * (solution.best - solution.vector) + c2 * (best_particle - solution.vector)
    new_solution = solution.apply_speed()
    return new_solution.vector</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.randNoise"><code class="name flex">
<span>def <span class="ident">randNoise</span></span>(<span>vector, params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randNoise(vector, params):
    method = params[&#34;method&#34;]

    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1
    
    noise = sampleDistribution(method, vector.shape, 0, strength, low, up)
    
    return vector + noise</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.randSample"><code class="name flex">
<span>def <span class="ident">randSample</span></span>(<span>vector, population, params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randSample(vector, population, params):
    method = params[&#34;method&#34;]
    
    low = params[&#34;Low&#34;] if &#34;Low&#34; in params else -1
    up = params[&#34;Up&#34;] if &#34;Low&#34; in params else 1
    strength = params[&#34;F&#34;] if &#34;F&#34; in params else 1

    popul_matrix = np.vstack([i.vector for i in population])
    mean = popul_matrix.mean(axis=0)
    std = (popul_matrix.std(axis=0) + 1e-6)*strength # ensure there will be some standard deviation
    
    rand_vec = sampleDistribution(method, vector.shape, mean, std, low, up)
    
    return rand_vec</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.sampleDistribution"><code class="name flex">
<span>def <span class="ident">sampleDistribution</span></span>(<span>method, n, mean=0, strength=0.01, low=0, up=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sampleDistribution(method, n, mean=0, strength=0.01, low=0, up=1):
    sample = 0 
    if method == &#34;Gauss&#34;:
        sample = np.random.normal(mean, strength, size=n)
    elif method == &#34;Uniform&#34;:
        sample = np.random.uniform(low, up, size=n)
    elif method == &#34;Cauchy&#34;:
        sample = sp.stats.cauchy.rvs(mean, strength, size=n)
    elif method == &#34;Laplace&#34;:
        sample = sp.stats.laplace.rvs(mean, strength, size=n)
    elif method == &#34;Poisson&#34;:
        sample = sp.stats.poisson.rvs(strength, size=n)
    else:
        print(f&#34;Error: distribution \&#34;{method}\&#34; not defined&#34;)
        exit(1)
    return sample</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.sbx"><code class="name flex">
<span>def <span class="ident">sbx</span></span>(<span>vector1, vector2, strength)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sbx(vector1, vector2, strength):
    beta = np.zeros(vector1.shape)
    u = np.random.random(vector1.shape)
    for idx, val in enumerate(u):
        if val &lt;= 0.5:
            beta[idx] = (2*val)**(1/(strength+1))
        else:
            beta[idx] = (0.5*(1-val))**(1/(strength+1))
    
    sign = random.choice([-1,1])
    return 0.5*(vector1+vector2) + sign*0.5*beta*(vector1-vector2)</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.simAnnealing"><code class="name flex">
<span>def <span class="ident">simAnnealing</span></span>(<span>solution, strength, objfunc, temp_changes, iter)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simAnnealing(solution, strength, objfunc, temp_changes, iter):
    p0, pf = (0.1, 7)

    alpha = 0.99
    best_fit = solution.fitness

    temp_init = temp = 100
    temp_fin = alpha**temp_changes * temp_init
    vector_new = solution.vector
    while temp &gt;= temp_fin:
        for j in range(iter):
            vector_new = gaussian(vector_new, strength)
            new_fit = objfunc.fitness(vector_new)
            y = ((pf-p0)/(temp_fin-temp_init))*(temp-temp_init) + p0 

            p = np.exp(-y)
            if new_fit &gt; best_fit or random.random() &lt; p:
                best_fit = new_fit
        temp = temp*alpha
    return vector_new</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.uniform"><code class="name flex">
<span>def <span class="ident">uniform</span></span>(<span>vector, low, up)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform(vector, low, up):
    return randNoise(vector, {&#34;method&#34;:&#34;Uniform&#34;, &#34;Low&#34;:low, &#34;Up&#34;:up})</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.xorCross"><code class="name flex">
<span>def <span class="ident">xorCross</span></span>(<span>vector1, vector2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xorCross(vector1, vector2):
    return vector1 ^ vector2</code></pre>
</details>
</dd>
<dt id="PyEvolAlg.operatorFunctions.xorMask"><code class="name flex">
<span>def <span class="ident">xorMask</span></span>(<span>vector, n, mode='byte')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xorMask(vector, n, mode=&#34;byte&#34;):
    mask_pos = np.hstack([np.ones(n), np.zeros(vector.size - n)]).astype(bool)
    np.random.shuffle(mask_pos)

    if mode == &#34;bin&#34;:
        mask = mask_pos
    elif mode == &#34;byte&#34;:
        mask = np.random.randint(1, 0xFF, size=vector.shape) * mask_pos
    elif mode == &#34;int&#34;:
        mask = np.random.randint(1, 0xFFFF, size=vector.shape) * mask_pos

    return vector ^ mask</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PyEvolAlg" href="index.html">PyEvolAlg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="PyEvolAlg.operatorFunctions.DEBest1" href="#PyEvolAlg.operatorFunctions.DEBest1">DEBest1</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.DEBest2" href="#PyEvolAlg.operatorFunctions.DEBest2">DEBest2</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.DECurrentToBest1" href="#PyEvolAlg.operatorFunctions.DECurrentToBest1">DECurrentToBest1</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.DECurrentToPBest1" href="#PyEvolAlg.operatorFunctions.DECurrentToPBest1">DECurrentToPBest1</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.DECurrentToRand1" href="#PyEvolAlg.operatorFunctions.DECurrentToRand1">DECurrentToRand1</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.DERand1" href="#PyEvolAlg.operatorFunctions.DERand1">DERand1</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.DERand2" href="#PyEvolAlg.operatorFunctions.DERand2">DERand2</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.blxalpha" href="#PyEvolAlg.operatorFunctions.blxalpha">blxalpha</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.cauchy" href="#PyEvolAlg.operatorFunctions.cauchy">cauchy</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.cross1p" href="#PyEvolAlg.operatorFunctions.cross1p">cross1p</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.cross2p" href="#PyEvolAlg.operatorFunctions.cross2p">cross2p</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.crossMp" href="#PyEvolAlg.operatorFunctions.crossMp">crossMp</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.dummyOp" href="#PyEvolAlg.operatorFunctions.dummyOp">dummyOp</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.firefly" href="#PyEvolAlg.operatorFunctions.firefly">firefly</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.gaussian" href="#PyEvolAlg.operatorFunctions.gaussian">gaussian</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.harmonySearch" href="#PyEvolAlg.operatorFunctions.harmonySearch">harmonySearch</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.laplace" href="#PyEvolAlg.operatorFunctions.laplace">laplace</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.multiCross" href="#PyEvolAlg.operatorFunctions.multiCross">multiCross</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.mutateRand" href="#PyEvolAlg.operatorFunctions.mutateRand">mutateRand</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.mutateSample" href="#PyEvolAlg.operatorFunctions.mutateSample">mutateSample</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.permutation" href="#PyEvolAlg.operatorFunctions.permutation">permutation</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.poisson" href="#PyEvolAlg.operatorFunctions.poisson">poisson</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.pso_operator" href="#PyEvolAlg.operatorFunctions.pso_operator">pso_operator</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.randNoise" href="#PyEvolAlg.operatorFunctions.randNoise">randNoise</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.randSample" href="#PyEvolAlg.operatorFunctions.randSample">randSample</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.sampleDistribution" href="#PyEvolAlg.operatorFunctions.sampleDistribution">sampleDistribution</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.sbx" href="#PyEvolAlg.operatorFunctions.sbx">sbx</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.simAnnealing" href="#PyEvolAlg.operatorFunctions.simAnnealing">simAnnealing</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.uniform" href="#PyEvolAlg.operatorFunctions.uniform">uniform</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.xorCross" href="#PyEvolAlg.operatorFunctions.xorCross">xorCross</a></code></li>
<li><code><a title="PyEvolAlg.operatorFunctions.xorMask" href="#PyEvolAlg.operatorFunctions.xorMask">xorMask</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>